---
layout: post
title: "LIS의 길이를 구하는 3가지 알고리즘"
date: 2019-11-30
description: "LIS, 최장 부분 수열의 길이를 구하는 3가지 방법을 살펴봅니다."
img:  /algorithm/lis-logo.jpg
categories: [Programming, Algorithm]
tags: [LIS, Longest-Increasing-Subsequence]
---

* **본 포스트는 데스크탑에 최적화되어 있습니다.**

## 0. Index

> 1. [들어가며](#1)
> 2. [LIS](#2)
>    - 2.1. [문제 소개](#2a)
>    - 2.2. [문제 정의](#2b)
> 3. [완전탐색](#3)
>    - 3.1. [완전탐색](#3a)
>    - 3.2. [알고리즘 선택: 입력의 크기를 바탕으로](#3b)
>    - 3.3. [문제 분해 및 조합](#3c)
> 4. [동적계획법](#4)
> 5. [이진탐색을 통한 최적화](#5)
> 6. [마치며](#6)
> 7. [자료 출처](#7)


<br>
<br id="1">

## 1. 들어가며

---

오늘 다루는 문제는 유명한 LIS다. 특정 플랫폼의 문제가 아닌, 유명한 예제가 될 수 있는 문제가 생각보다 없다는 것은 내 잘못된 생각이었다. 종만북을 다시 공부하면서 LIS가 꽤나 유명한 문제라는 것을 알게 됐고 그에 대한 풀이를 준비했다. 이번에는 세 가지의 방법을 준비했는데: 완전탐색과 동적계획법, 이진탐색을 통한 최적화 알고리즘이 있다. 가끔 우리의 익숙한 생각 패러다임 자체를 변화시키면 문제를 더 쉽게 해결할 수 있는 순간들이 있는데 세 번째 풀이가 딱 그런 것 같다. 알고리즘이 어렵지도 않고 꽤나 우아하다.

간만에 문제다운 문제를 다루게 됐는데 얼마나 걸릴지 모르겠다. 있을지도 모르는 익명의 독자들을 위해 도움이 될 수 있도록 해보겠다.

여기서 다룬 두 풀이는 종만북의 풀이를 많이 참고했고 마지막 풀이는 핵심 아이디어를 통해 직접 구현했다.


<br>
<br id="2">

## 2. 문제 소개

---

LIS는 _Longest Increasing Subsequence_ 의 약자로 한글로는 '최장 부분수열', 또는 '최대 증가 부분수열'로 불린다. **LIS는 어떤 수열에서 특정 부분을 지워서 만들어낼 수 있는 증가 부분수열(increasing subsequence) 중 가장 긴 수열**을 말하는데 이때 **부분수열의 숫자들은 원 배열에서 위치가 이어져 있지 않아도 된다는 주요한 특징이 있다.**

또 보통 증가는 순증가(strictly increaing)와 단조증가(monotonically increasing)로 나눌 수 있다. 순증가는 $$[1, 2, 3]$$ 처럼 뒤의 숫자가 앞의 숫자보다 무조건 큰 경우를 말하고, 단조증가는 $$[1, 2, 2, 3]$$처럼 앞의 원소가 뒤의 원소 이상인 증가를 말한다. 단조증가 수열의 대표적인 예가 피보나치 수열이 있는데 피보나치 수열의 처음을 어떻게 잡아도 반드시 초반에 1이 두 번 반복되기 마련이다. LIS에서는 보통 순증가하는 부분수열을 대상으로 한다.

예를 들어 원 배열이 $$[1, 4, 6, 8, 3, 5, 6, 7]$$일 때 $$[1, 6, 8]$$, $$[4, 6, 8]$$, $$[1, 8]$$은 증가 부분수열인데, 이 중 가장 긴 부분열은 $$[1, 3, 5, 6, 7]$$이 된다. 이때 중간의 $$4, 6, 8$$은 생략한 것을 알 수 있다.

LIS를 직접 구하는 등 LIS에 관한 많은 문제를 만들 수도 있을테지만 **이 포스트에서는 원 수열의 LIS의 길이를 구하는 방법을 다루도록 한다.**


<br>
<br id="3">

## 3. 완전탐색

---

<br class="3a">

### 3.1. 아이디어 얻기

가장 일차원적으로는 증가 부분수열을 모두 만들어보면서 그중 가장 긴 증가 부분수열의 길이를 구하면 될 것 같다. 즉 완전탐색으로 생각해보자. 가능할까?

![lis example1](/assets/img/algorithm/lis-array1.png)

다음은 어떤 수열 $$arr$$이다. 이 수열에서 수많은 증가수열을 만들 수 있는데 그중 하나를 만들어보자.

![lis example2](/assets/img/algorithm/lis-array2.png)

만든 수열은 $$[4, 5, 6, 7]$$로 무난한 예시다. 이 부분수열을 $$S$$라고 할 때 이를 통해 우리는 적어도 두 가지를 알 수 있다.


1. **정수 i, j에 대해 i < j이면, S[i] < S[j]다.(0 <= i, j <= \|S\|)**
1. **정수 i, j에 대해 S[i] < S[j]이면, 원 배열 arr에서의 S[i], S[j] 두 수의 위치 전후관계는 같다.(0 <= i, j <= \|S\|)**

이 두 명제는 LIS의 정의상 명확하다.

<br>

그렇다면 이 명제를 활용해서 LIS의 길이를 구하는 함수를 만들자.

이 함수는 완전탐색답게 모든 증가 부분수열을 고려한다. 함수는 배열을 받아 **원 배열에서 증가 부분수열의 첫 수를 선택하고, 그 다음 수가 될 수 있는, 위의 두 명제처럼 첫 수보다 원 배열에서 뒤에 있고 큰 후보값들의 배열을 추려 재귀해나가면 될 것 같다.** 재귀가 가능한 것은 숫자를 하나 선택할 때마다 같은 과정을 진행할 수 있기 때문이다.

이때 증가수열이 생성되면서, 다시 말해 **재귀함수가 진행되면서 내 앞의 숫자가 어떤 숫자였는지는 중요하지 않다. 이미 내가 선택되었다는 것은 그 이전의 숫자가 나보다는 작은 숫자라는 것을 말해주고, 또 여기서는 길이만 구하기 때문에 앞선 콜에서 이전값의 길이 1만을 계속 더해나가면 되기 때문이다.**

이 아이디어를 코드로 옮기자.


<br class="3b">

### 3.2. 실제 코드

실제 코드는 다음과 같다.

```python
def lis(arr):
    if not arr:
        return 0
    
    ret = 1
    for i in range(len(arr)):
        nxt = []
        for j in range(i+1, len(arr)):
            if arr[i] < arr[j]:
                nxt.append(arr[j])
        ret = max(ret, 1 + lis(nxt))
    return ret	
```

매우매우 짧은데 각 부분을 설명하면 다음과 같다.

```python
if not arr:
   return 0
```

배열이 빈 값이면 당연히 답은 0이다. **이 조건은 단순히 예외처리뿐 아니라 재귀가 진행되면서 종료될 base case이기도 하다.**

```python
ret = 1
for i in range(len(arr)):
    nxt = []
    for j in range(i+1, len(arr)):
        if arr[i] < arr[j]:
            nxt.append(arr[j])
    ret = max(ret, 1 + lis(nxt))
return ret	
```

_ret_ 을 초기화한다. 위의 조건식에 부합되지 않았다는 것은 원소가 하나는 들어있다는 뜻이기 때문에 최소값 1로 설정한다.

<br>

다음 코드가 중요하다. for문이 2중으로 중첩되어 있는데 각 for문의 역할은 다음과 같이 구분된다:

1. **첫 번째 for문은 배열에서 증가수열의 시초가 될 첫 수를 선택한다. 이 완전탐색 함수는 모든 증가부분수열을 다루기 때문에 입력된 배열의 모든 수가 증가수열의 첫 번째 숫자가 될 수 있다.**
1. **두 번째 for문은 두 가지 조건을 만족하는 다음 수들의 후보를 배열로 추린다.**

두 번째 for문이 종료되면 _nxt_ 에는 이 수(_arr[i]_)로 만들 수 있는 증가 부분수열의 두 번째 값들의 후보가 담긴다. 그 후에 _ret_ 을 _nxt_ 를 활용한 재귀식의 값으로 경신해나간다.

**_1 + lis(nxt)_ 코드를 주목해야 한다. 앞서 살폈다시피 각 함수는 나보다 앞선 값이나 생성되던 중간의 배열을 알 필요가 전혀 없다. 따라서 재귀를 호출할 때 _arr[i]_ 의 크기 1만 더해주면 완성된 증가 부분수열의 길이를 구할 수 있는 것이다.** 재귀가 깊어지면서 1은 계속 더해지기 때문에 더 이상 나보다 크고 뒤에 있는 원소를 발견할 수 없어 입력이 `[]`이 됐을 때 종료되며 그 수들의 합이 곧 정답이 된다.





<br>
<br id="1">

## 1.



<br>
<br id="1">

## 1.



<br>
<br id="1">

## 1.

* []()
* []()
* []()
* [자연수 제곱수열의 합 공식: mathbang.net](https://mathbang.net/628)
* []()
* []()
* []()


