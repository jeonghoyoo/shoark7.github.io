---
layout: post
title: Shell 사용의 핵심: I/O Redirection에 대하여
date: 2018-??-??
description: 리눅스 쉘을 활용하는 데 필수적인 Redirection 개념에 대해 자세히 살펴봅니다.
img:  /shell-programming/logo-redirection.jpg
categories: [Programming, Shell-programming]
tags: [Python, shell, Redirection, IO_Redirection]
---


## 0. 들어가며

---

쉘 프로그래밍 [직전 포스트](https://shoark7.github.io/programming/knowledge/what-is-standard-stream.html)는 표준 입출력에 관한 포스트였다. 입출력은 프로그램과 프로그램을 사용하는 유저 모두에게 매우 중요하기에 표준 입출력에 대한 개념은 꼭 유닉스 유저가 아니라도 이해할 필요가 있다. 그것이 저 포스트의 의의라고 생각한다.  

하지만 동시에 **저 포스트는 유닉스 쉘을 활용하는데 필수적인 I/O Redirection을 이해하기 위한 전 단계**이기도 하다. **`I/O Redirection`은 쉘의 가장 중요한 기능들 중 하나로, 난 이 기능이 없다면 쉘 리눅스를 도저히 쓸 자신이 없다.** 차라리 윈도우 GUI로 넘어가겠다. 이 개념은 쉘의 활용성을 극대화해서, GUI가 아니기에 러닝커브가 높을 수밖에 없는 쉘의 단점을 덮어버릴 정도로, 그러니까 그 커닝커브를 극복하는 것이 기꺼이 가치 있을 정도로 의미가 있다. 쉘을 제대로 쓰기 위해서는 이 개념을 자세히 훝고, 또 실제로 사용해야 한다.  

이번 포스트에서는 쉘의 I/O Redirection에 대해 자세히 살펴본다. **먼저 그 개념을 훑은 뒤, 프로세스의 입출력을 전환하는 다양한 연산자들을 살펴보고 그 찬란한 활용사례를 살펴보겠다. 또한 여러 프로세스를 연쇄적으로 연결할 수 있는 Pipe 연산자를 알아보고 활용사례를 몇 가지 살펴보도록 하자.**




## 1. I/O Redirection이란?

---

직전 포스트는 표준 입력과 표준 출력을 다뤘고 그 둘은 프로세스에 따로 값을 주지 않을 경우의 기본 입력과 출력이라고 설명했다. **쉘 프로그램들은 대부분 표준 입력은 기본적으로 키보드로 바로 연결되어 있고, 표준 출력은 화면(콘솔)로 연결되어 있다.** 우리가 쉘에 키보드로 명령을 출력하고 화면으로 결과를 본 것은 '그냥 당연한거지;' 이상의 의미가 있었던 것이다.

'I/O Redirection'에서 `I/O`는 _Input_ / _Output_ 의 약자로 입력과 출력을 뜻한다. 사용자는 원할 시 프로그램에 표준이 아닌 임의의 입력과 출력을 지정해줄 수 있다. `Redirection`은 '재지정'의 의미로 '방향을 돌린다' 는 의미를 가지고 있다. 이 둘을 합치면 **실행 중인 프로세스의 표준 입력 또는 표준 출력을 임의의 입력 또는 출력으로 지정하는 것을 `Redirection`이라고 한다.** 

<br>

그럼 그 의미는 무엇일까? 처음 쉘을 다룰 경우, 우리가 사용하는 대부분의 명령어는 화면에 결과를 출력한다. 따로 지정하지 않았기에(아니면 못했기에) 표준 출력인 화면에 결과를 내놓은 것이다. 하지만 때로는 **그 결과를 쉘 종료 시 사라지는 휘발적인 화면 위가 아닌, 반영구적으로 저장될 수 있는 파일에 남기고 싶을 때가 있다.** 가령, 리눅스 환경에서 서버 접근 로그 파일을 남기고 싶을 경우 화면에 결과를 띄우는 것은 실제 배포 환경에서는 가치가 없을 것이다. 많은 경우, 접근 로그와 어떤 식으로든 발생한 에러 로그를 'access.log', 'error.log' 등의 파일에 남긴다. 이런 수북히 쌓인 로그는 향후 트래픽 분석 등의 용도로 사용될 수 있을 것이다. **표준 출력이 아닌 파일로 출력이 전환됐다는 것은 어떤 식으로든 사용자의 조작이 있었다는 것이고, 이것이 곧 `Redirection`이다.**  

우리는 이제 그 '조작'하는 것을 배우고 활용해볼 것이다.



## 2. 주요 연산자 확인

---

입출력을 전환하는 것은 쉘에 명령어를 입력한 뒤 입출력을 전환해주는 Phrase를 입력해주어야 한다. 이때 Phrase는 어떤 전환인지 나타내는 전환 연산자와 전환 대상 파일로 이루어진다. 이번 장에서는 **전환의 종류가 입력, 출력, 에러일 때의 전환 연산자를 각각 살피고, 이 둘의 중요한 쓰임새들을 추가로 살펴보자.**


### 2.1. `>`: 표준 출력 전환 연산자

**`>`는 표준출력 전환 연산자로 표준 출력을 임의의 대상으로 옮긴다.** 명령어의 출력을 화면이 아닌 임의의 다른 파일로 옮기고 싶다면 이 연산자를 사용해 방향을 전환할 수 있다.  

예제로 파악해보자. `test`라는 폴더 안에 있는 파일들의 목록을 확인하되 그 결과를 화면이 아닌 `ls-test.txt`라는 이름의 파일에 저장하고 싶다고 하자. 코드는 정말 간단하다.

```sh
$ ls test > ls-test.txt
```

`>` 연산자를 사용해 출력 방향을 파일로 옮겼다. 화면에는 어떤 결과도 출력되지 않는다. 출력의 방향이 화면이 아니기 때문이다. 대신 파일의 내용을 확인해보면 원하던 결과물이 들어있음을 알 수 있다.

```sh
$ cat ls-test.txt

aws-scripts my_module.py open-tmux ...
```

2장 설명하기 전까지 무슨 말을 하는지 아리송했다면 이 예제로 한 번에 파악했으리라 생각한다. 아무 디렉토리나 잡고 실제로 해보자. **존재하는 디렉토리를 대상으로 했다면 문제없이 작동한다.** 없는 디렉토리를 지정한 경우는 표준 오류 전환 연산자에서 살펴보도록 하자.

---


### 2.2. `<`: 표준 입력 전환 연산자


**`>`가 표준 출력을 전환했다면 그를 뒤집은 `<`는 표준 입력을 전환하는 연산자이다.** 쉘과 쉘에서 실행하는 프로그램은 대부분 표준 입력이 키보드로 설정되어 있는데 입력을 키보드가 아닌 임의의 다른 대상으로 지정할 수 있다.  

이번에도 예제로 파악하자. 우리는 _cat_ 이라는 프로그램을 이미 배웠다. [필수 쉘 커맨드를 소개한 포스트](https://shoark7.github.io/programming/shell-programming/Top-basic-unix-shell-command.html)에서 **_cat_ 은 자연수 개수의 파일을 입력 받아 그 내용을 하나로 묶어서 화면에 출력하는 프로그램이라고 소개했다.**

하지만 저 설명은 편의를 위해 설명한 것으로 **사실 _cat_ 은 파일의 이름을 입력 받지 않아도 된다. 이때는 프로세스의 표준 입력이 키보드로 설정되어 있으며** 이를 이용해 세상에서 가장 초라한 텍스트 에디터를 만들 수 있다.  

**_cat_ 의 표준 입력이 키보드일 경우, 사용자는 엔터를 포함해 원하는 텍스트를 계속 입력할 수 있다.** 입력을 마치고 싶으면 \<CTRL+D\>를 입력하면 되는데 이 키는 쉘에서는 파일의 끝을 뜻하는 EOF 문자로 연결되어 있다. 입력이 종료되면 화면에 내가 입력한 것이 그대로 출력된다.


```sh
$ cat

I jumped into Han River.(엔터)
Water was very cold, gold and old.(엔터)
Where am I now, water? non-water? Who cares(엔터)
(<CTRL+D> 입력)

I jumped into Han River.
Water was very cold, gold and old.
Where am I now, water? non-water? Who cares
```

_cat_ 을 단독으로 입력했기 때문에 표준 출력은 화면, 표준 입력은 키보드로 설정되어 있기 때문에 키보드로 입력한 내용이 화면에 바로 출력됐다.  

이를 이용하면 파일에 간단하게 한 줄 입력하고 싶을 때 `vim` 등 기타 에디터를 열지 않고도 파일을 쉽게 만들 수 있다.

```
$ cat > test.txt

Go away!!
(<CTRL+D> 입력)

$ test.txt

Go away!!
```

`> test.txt`는 표준 출력을 전환하는 Phrase이기 때문에 _cat_ 에는 출력 지정은 있지만 입력은 아예 없다. 그래서 표준 입력으로 입력을 받아 파일에 출력했다.

<br>

자, 잡설이 길어졌는데 이 특성을 사용해 `<`를 활용해보자. _cat_ 의 표준 입력이 키보드라고 했다. 그렇다면 **입력를 전환해 입력을 키보드에서 임의의 다른 파일로 지정할 수 있다.**

```sh
$ cat < test.txt

Go away!!
```

입력의 방향이 키보드가 아니기 때문에 내가 입력할 필요 없이 파일의 내용이 그대로 출력되었다.  

여기서 '어? 저거 `cat test.txt`랑 똑같잖아 임마!'라고 생각이 들어야 한다. 이건 표준 입력이 이상한 것이 아니라 _cat_ 이 그렇게 작동하도록 설정되었기 때문에 그렇다. **_cat_ 명령어에는 파일의 이름을 입력하면 입력을 그쪽으로 전환하도록 _cat_ 내부에 설정되어 있기 때문에 결과적으로 두 명령어의 결과가 같은 것이다.** 한 문제를 해결하는 방법은 여러 가지인 것이 좋고, 지금 이 두 가지 경우가 딱 그 사례인 것 같다. 이는 유닉스에서 지향하는 바이기도 하기에 두 가지 다 알아두는 것이 나쁘지 않다.

<br>


다른 사례를 하나 더 살펴보자. 매우 간단한 파이썬 프로그램을 만들텐데 이 프로그램은 이름과 이메일, 직업을 입력 받아 정해진 형식으로 문자열을 출력하는 일을 한다.


```python
# test.py에 내용을 저장한다.

name = input("너의 이름은? : ")
email = input("너의 이메일은? : ")
job = input("너의 직업은? : ")
print()

print(f'{name}이의 이메일은 {email}이고 이 자의 직업은 {job}입니다')
```

이 `test.py`를 실행해서 값을 입력해보자.

```sh
$ python test.py

너의 이름은? : 박성환
너의 이메일은? : shoark7@naver.com
너의 직업은? : 백수

박성환이의 이메일은 shoark7@naver.com이고 이 자의 직업은 백수입니다
```

이런 프로그래밍 예제는 프로그래밍을 처음 배울 때 정말 흔하게 해보는 것 같다. 이 예제의 문제점은 무엇일까? 내 이름과 이메일, 직업 등은 잘 바뀌지 않기 때문에 입력값도 대부분 일정하다. 그럼에도 **파이썬 모듈을 실행할 때마다 저 귀찮은 입력을 3줄을 다 해줘야 하는 것이 이 기능의 치명적인 약점이다.** 그렇다면 해결 방안이 있을까? 당연, 입력을 전환하자.  

현재 저 프로그램은 3줄의 입력을 모두 표준 입력, 즉 키보드로 입력 받고 있다. 그렇다면! **입력을 키보드가 아닌 미리 저장해둔 개인정보 파일로 전환한다면 되지 않을까?**  

먼저 내 데이터를 data.txt에 저장하자.

```
$ cat > data.txt

박성환
shoark7@naver.com
백수
(<CTRL+D> 입력)
```

그 다음 모듈을 실행하되 입력을 이 데이터 파일로 돌려주면!

```sh
$ python test.py < data.txt


너의 이름은? : 너의 이메일은? : 너의 직업은? : 
박성환이의 이메일은 shoark7@naver.com이고 이 자의 직업은 백수입니다
```

어떤가? 이런 활용은 문제 예시를 미리 제공하는 알고리즘 문제 해결 사이트들에서도 유용하게 쓸 수 있다.

---


### 2.3. `2>`: 표준 에러 전환 연산자


### 2.4. `>>`의 사용: 덮어쓰기가 아닌 이어붙이기

---

### 2.5. 표준에러 & 표준출력을 동시에 전환하기


## 3. 명령어 연결하기: Pipe 연산자

---

## 4. 마치며

---


